TITLE::Codices Guide
summary::Guide to working with the Codices quark
categories::Libraries>Codices
related::Overviews/Codices, Guides/CodexProxier
keyword::hybrid, composite, composition

section::Description
The Codices quark establishes a framework for developing modular class interfaces using arbitrarily defined scriptable components. For instance, a class written in this framework that iteratively evaluates a function within a routine might implement only the routine, leaving the function itself to be defined later by the user. As a result, an object of this class can support any number of diverse configurations without compromising the functionality of the class itself. In this way, the framework aims to support a best-of-both-worlds situation that balances the specficity of a compiled class's interface with the open-ended potential of scripting.

link::Classes/CodexComposite:: coordinates these operations and maintains a directory of sets of modules on behalf of its subclasses. link::Classes/CodexHybrid:: inherits from CodexComposite, handling the process of adding and removing link::Classes/SynthDef:: modules from a given server. 

section::Module directories

Each class that inherits from CodexComposite will have its modules stored in a central directory on the machine. The modules themselves are organized in layers of subfolders that are specified on a per-class-per-collection basis. The path to the directory can be gotten and set through link::Classes/CodexComposite#*directory::. If the path to the directory of modules is reset, the new configuration will persist across sessions of the link::Classes/Interpreter:: (see link::Classes/CodexStorage::).

note::Be sure to configure the path to the modules directory. By default, the module directory is stored in the folder of this quark.
code::
//Check where the directory is.
CodexComposite.directory.postln;

//Replace this path with something you prefer.
CodexComposite.directory = "~/Documents/scmodules".standardizePath;
::
::
An outline of the directory looks like this:

Module Directory
tree::
	##Class 0
		tree::
			##Module folder
				tree::
					##Module
					##Module
					##Module
				::
			##Module folder
				tree::
					##Module
					##Module
					##Module
				::
		::
	##Class 1
		tree::
			##Module folder
			tree::
				##Module
			::
		::
::

subsection::Class folders
Class folders are generated automatically. However, the circumstances regarding when that happens vary. For instance, a class that a contains reference to a preconfigured version of its modules will create both its class folder when sclang is recompiled as well as a subfolder populated with copies of these modules, and this process will be repeated if either of these folders is deleted. If no versions are specified, then once a class is instanced for the first time the framework will generate both the class folder and a folder of modules filled with templates. 

subsection::Module folders
Modules are stored as teletype::.scd:: files within the subfolders of each class folder; each of these subfolders contains variations of the modules templated by the class. As a result, a class expects that modules representing specific sclang objects exist but does not need to now emphasis::how:: they exist. As such, the module loaded from the file teletype::default/sequence.scd:: can be different from the one loaded from the file teletype::experimental/sequence.scd:: so long as both scripts return an object of the same type.

There is no prescribed limit to the number of modular variations that can exist per class. An instance of a subclass of CodexComposite is told to load one of these collections either by supplying a symbol to the teletype::moduleSet:: argument of link::Classes/CodexComposite#*new:: or by setting the value of the field link::Classes/CodexComposite#-moduleSet::. 
note::To see all available module sets, use the method link::Classes/CodexComposite#*moduleSets::.::
In both cases, the user has an opportunity to point to a different set of modules by supplying a second argument. In the case where the set of modules specified by the first argument does not exist but those specified by the second argument do, then a new set of modules will be copied from those pointed to by the second argument into a directory that can be later accessed with the symbol of the first argument. However, if this second set of modules is not specified or does not exist, then the new directory associated with the first argument's symbol will be filled with link::Classes/CodexTemplater##templates::.  

subsection::Modules
As stated above, modules are teletype::.scd:: files containing scripts that return an arbitrary object. When a set of modules is requested for the first time, these scripts are loaded into sclang, collected with an instance of link::Classes/CodexModules::, which is in turn stored in an instance of link::Classes/CodexCache::. Copies of the cached modules then can be accessed via link::Classes/CodexComposite#-modules::. CodexModules behaves like an link::Classes/IdentityDictionary:: where each module it stores is associated with a key derived from its respective file name . For instance, a pattern loaded from teletype::sequence.scd:: is accessible using the key \sequence. If the name of the file were teletype::SillySequence.scd::, its associated module would be accessed using the key \sillySequence.

Furthermore, if the source file of a module currently loaded into an instance of a given Codex is edited, calling link::Classes/CodexComposite#-reloadScripts:: will reload the objects from the scripts into the cache before copying them into the instance that called the method. Subsequently, all new instances that call for modules from that same collection will reflect these updates. To update currently existing instances, invoking link::Classes/CodexComposite#-reloadModules:: will refresh modules from the now modified cache. This process does not require recompiling sclang.

subsection::Contributing versions 
CodexComposite supports the ability to ship any of its subclasses class with sets of preconfigured modules. This is done by overwriting the method link::Classes/CodexComposite#*contribute#*contribute::, which is passed a link::Classes/List:: that must be supplied with an array of two items: a symbol or string representing the name of the set of modules to be cloned to the directory as well as the path where the modules are currently stored. Ideally, this path should be located within the folder of the project implementing the class. 

There are four short steps required to make a contribution: first, checkout a new branch of your clone of the project; second, add your version of the modules to the project folder; third, point to your projects by adding its name and path (in that order) as an array to the list of versions in the class's implementation; and finally, commit your changes to the branch and submit a pull request for the project. 

By implementing this framework as a platform that publishes diverse approaches common projects, my hope is to promote a collaborative music-making process that mirros the ethos of the libre/open-source software movements in which the SuperCollider project itself is developed. More information about the procedures by which one participates either with Codex-based projects or with SuperCollider can be found by visiting the following link: 
link::https://supercollider.github.io/contributing/::.

section::CodexExample
Developing a class that inherits from CodexComposite is relatively simple. No constructor is needed. The only requirement is that the developer fill out the method link::Classes/CodexComposite#*makeTemplates::, which takes an instance of link::Classes/CodexTemplater:: as an argument. In fact, it is this method that defines the modules of a class. For instance, if you are making a class that requires a pattern that can be accessed via the key \sequence, then the templater instance must be told to generate a pattern with the name "sequence".

A basic implementation of a class that inherits from CodexComposite is displayed below. There, a single module — a pattern called "sequence" — is defined, and the class implements two other methods that play and stop the module.
code::
CodexExample : CodexComposite {
	var player;
	
	//initComposite is called immediately after modules are loaded into the class. 
	//Initialize instance variables here if you don't want to rewrite the constructor.
	initComposite {}

	*makeTemplates { | templater | 
		templater.pattern( "sequence" );
	}

	play { | clock(TempoClock.default) |
		if(player.isPlaying.not, {
			player = modules.sequence.play(clock, modules.asEvent);
		});
	}

	stop { 
		if(player.isPlaying, { 
			player.stop;
		});
	}
}
::

subsection::Usage
Below represents code for interacting with the class whose implementation is displayed immediately above.
code::
x = CodexExample.new(\version1);

//Insepct the modules.
x.modules.postln;

(
//A folder now exists in the modules' directory.
var path = CodexComposite.directory;
PathName(path).folders.do({|item|
	item.folderName.postln;
});
)

(
//Inspecting that folder, see that an entry exists for \version1.
var path = CodexExample.classFolder;
PathName(path).folders.do({|item|
	item.folderName.postln;
});
)

//This is easier done using the .moduleSets class method
CodexExample.moduleSets;

//Open up the currently loaded scripts.
//This is only supported for scide, scvim, and scnvim.
x.openModules; 

//If you want to make a new set of modules, that is easy.
x.moduleSet = \version2;

//There are now more moduleSets accessible to the class.
CodexExample.moduleSets.postln;
x.modules.postln;

//Open the \version2 set of modules.
x.openModules; 

//If you edit them, load the changes back into the instance. 
x.reloadScripts; 

//You can switch back and forth between existing modules too.
x.moduleSet = \version1;

//You can clone a new folder from \version2.
x.moduleSet_(\version3, \version2);

//Open the new modules to see that the modules have been copied. 
x.openModules;
::

SECTION::CodexHybrid
CodexHybrid extends the procedures of CodexComposite to process SynthDef modules. It does this by reformatting their names to prevent clashes before sending each respective SynthDef to a given server. SynthDef modules will only be added to the server when unique collections of modules are added to the cache maintained by CodexComposite.

subsection::SynthDef naming
CodexHybrid forces each class to rename its SynthDef modules, appending the user-defined key with the name of both the modules' set and also the class itself. As a result, multiple module sets can be cloned from one another and then instanced simultaneously without any naming clashes. This occurs according to the following format: teletype::ClassName_moduleSet_synthDefName::. In other words, if a SynthDef is called "world" in a set "milkyWay" of the hypothetical class "Universe," then CodexHybrid will rename that SynthDef to "Universe_milkyWay_world." If that module set is then cloned into a new one called "andromeda," its SynthDef would be renamed to "Universe_andromeda_world."

Once these sets of modules are loaded, the class will not re-add the associated SynthDefs for the duration of the server session unless they are removed using link::Classes/CodexHybrid#-removeSynthDefs::. In CodexHybrid, the method teletype::-reloadScripts:: is overloaded to include teletype::-removeSynthDefs:: so that SynthDefs are updated on the server as the scripts themselves are updated. 

note:: To ensure that SynthDef names are accessed consistently, it is best not to hardcode the names of SynthDefs either into any modules or class implementations. Rather, calling the method link::Classes/SynthDef#-name#-name:: on the associated SynthDef module will produce more consistent results.
code::
	~someHybrid.modules.synthDef.name;
::
::

section::CodexExampleHybrid
The below implementation example builds upon the previous one by defining a  SynthDef module to be sequenced by a pattern and demonstrates the proper way to add default modules to a Codex class. 

Notice also that teletype::initComposite:: has been replaced by teletype::initHybrid::. This is because the special procedures of CodexHybrid occur in the method teletype::initComposite::, subsequently calling teletype::initHybrid::, further continuing the chain of initialization methods.

code::
CodexExampleHybrid : CodexHybrid {
	var player;

	*contribute { | versions |
		var toQuark = Main.packages.asDict.at(\Codices);
		var toExample = toQuark+/+"Classes/Examples/Modules";

		versions.add(
			[\example, toExample]
		);
	}

	//initHybrid is called immediately after initComposite, 
	//which contains the code that makes CodexHybrid work.
	initHybrid {}

	*makeTemplates { | templater |
		templater.pattern( "sequence" );
		templater.synthDef( "synthDef" );
	}

	play { | clock(TempoClock.default) |
		if(player.isPlaying.not, {
			player = modules.sequence.play(clock, modules.asEvent);
		});
	}

	stop {
		if(player.isPlaying, {
			player.stop;
		});
	}
}
::
subsection::Usage
Here is an outline of how to interact with the CodexExampleHybrid class. It should make sounds.

code::
//Inspect existing module sets
CodexExampleHybrid.moduleSets.postln;

//Instance a new CodexExampleHybrid.
s.waitForBoot({ x = CodexExampleHybrid.new(\example) });

//Inspect the modules.
x.modules.postln;

//Inspect the name of the SynthDef.
x.modules.synthDef.name.postln;
//Or, use the shortcut
x.synthDef.name.postln;

//Play it to hear sounds. 
x.play;

//Stop it to stop sounds. 
x.stop;

//Clone a new moduleSet to observe the new SynthDef name.
x.moduleSet_(\example2, \example);
x.modules.synthDef.name.postln;

//Edit the modules if you want, then reload the scripts. 
x.openModules;
x.reloadScripts; 
x.closeModules;

//Play it to hear sounds.
x.play;
::

section::But wait! There's more!

For more classes and frameworks that are based on the procedures outlined in this guide, check out the following link::https://github.com/ianmacdougald/CodicesMore##quark::. It is made up of my repository of still-in-the-works tools for composing electronic music, quickly fabricating and storing configurations of GUI elements, making virtual instruments, and other stuff that is still to come in the future!

