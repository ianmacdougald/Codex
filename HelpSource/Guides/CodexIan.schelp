TITLE::CodexIan Guide
summary::Guide to working with the library CodexIan
categories::Libraries>CodexIan
related::Overviews/CodexIan
keyword::hybrid, composite, composition

section::Description
CodexIan is a collection of classes that establishes a framework for making and developing musical projects in sclang. Objects defined under this framework balance the specificity of a compiled class's interface with the open-ended, experimental potential of scripting. As such, a class written using its features only has to describe high-level interactions between scriptable components whose definitions are largely arbitrary. 

For instance, a class written to sequence patterns in a routine might implement only the routine and then leave the patterns to be loaded from external scripts called modules. As a result, the patterns of this example can be redefined at any point and redeployed without the need for recompiling sclang.  

Moreover, the modules themselves can be edited, cloned, and templated at will. As such, every class developed under this framework can endlessly vary its core functions without additional developmental overhead.

link::Classes/CodexComposite:: coordinates these operations and maintains a directory of sets of modules on behalf of its subclasses. link::Classes/CodexHybrid:: inherits from CodexComposite, handling the process of adding and removing link::Classes/SynthDef:: modules from a given server. A description of how to work with both classes is described in the following guide. 

section::Module directories

Each class that inherits from CodexComposite will have its modules stored in a central directory on the machine. The modules themselves are organized in layers of subfolders that are specified on a per-class-per-collection basis. The path to the directory can be gotten and set through through link::Classes/CodexComposite#*directory::. If the path to the directory of modules is reset, the new configuration will persist across sessions of the link::Classes/Interpreter:: (see link::Classes/CodexPaths::).

note::Be sure to configure the path to the modules directory. By default, the module directory is stored in the folder of this quark.
code::
//Check where the directory is.
CodexComposite.directory.postln;

//Replace this path with something you prefer.
CodexComposite.directory = "~/Documents/sc-modules".standardizePath;
::
::
An outline of the directory looks like this:

Module Directory
tree::
	##Class 0
		tree::
			##Module folder
				tree::
					##Module
					##Module
					##Module
				::
			##Module folder
				tree::
					##Module
					##Module
					##Module
				::
		::
	##Class 1
		tree::
			##Module folder
			tree::
				##Module
			::
		::
::

subsection::Class folders
Class folders are generated automatically. However, the circumstances regarding when that happens vary depending. For instance, a class that specifies a set of default modules will create its class folder when sclang is recompiled as well as a subfolder called "default" populated with copies of these modules. Moreover, this process will repeat if either of these folders is deleted. If default modules are not specified, the first time a class is instanced, an entry will be made in the directory for the class and a modules folder filled with templates will be generated.

subsection::Module folders
Modules are stored as teletype::.scd:: files within the subfolders of each class folder; each of these subfolders contains variations of the modules templated by the class. As a result, a class expects that modules representing specific sclang objects exist but does not need to now emphasis::how:: they exist. As such, the module loaded from the file teletype::default/sequence.scd:: can be different from the one from teletype::experimental/sequence.scd:: so long as both scripts return an object of the same type.

Furthermore, there is no prescribed limit to the number of modular variations that can exist per class. An instance of a subclass of CodexComposite is told to load one of these collections either by supplying a relative name to the teletype::moduleSet:: argument of link::Classes/CodexComposite#*new:: in the form of a symbol or string or by setting the value of the field link::Classes/CodexComposite#-moduleSet::. In both cases, the user has an opportunity to point to a different set of modules using the argument teletype::from::. When the first set of modules does not already exist and the second set does, the first set will be cloned from the second. If no second set of modules is specified or does not exist, a new corresponding folder of modules will be generated from link::Classes/CodexTemplater##templates::.  

subsection::Modules
As stated above, modules are teletype::.scd:: files containing scripts that return an arbitrary object. When a set of modules is requested for the first time, these scripts are loaded into sclang, collected as an link::Classes/Event::, and stored in an instance of link::Classes/CodexCache::. Copies of the cached modules then can be accessed via link::Classes/CodexComposite#-modules::. The name of each respective module in the event is taken from the name of its source file. For instance, a pattern loaded from teletype::sequence.scd:: is accessible using the key \sequence. Moreover, if the name of the file were teletype::SillySequence.scd::, its associated module would be accessed using the key \sillySequence.

If the source file of a module currently loaded into an instance of a CodexComposite-typed class is edited, simply calling link::Classes/CodexComposite#-reloadScripts:: will reload the objects from the scripts into the cache before copying them into the instance that called the method. Subsequently, all new instances that call for modules from that same collection will reflect these updates. To update currently existing instances, invoking link::Classes/CodexComposite#-reloadModules:: will refresh modules from the now modified cache. This process does not require recompiling sclang.

subsection::Contributing versions 
CodexComposite supports the ability to ship any class with a set of pre-configured modules, representing a specific take on its functionality. This is done by overwriting the method link::Classes/CodexComposite#*contribute#*contribute::, which is passed a list for storing arrays of two items—a symbol or string representing the name of the set of modules to be cloned to the directory as well as the path where the modules are stored. Ideally, this path should be located within the folder of the project also implementing the class. 

There are four short steps required to make a contribution: first, checkout a new branch of your clone of the project; second, add your version the modules to the project folder; third, point to your projects by adding its name and path (in that order) as an array to the list of versions in the class's implementation; and finally, commit your changes to the branch and submit a pull request for the project. 

More or less, this project mirrors the way in which one contributes to SuperCollider itself. As such, for a more detailed explanation, visit the following link: 
link::https://supercollider.github.io/contributing/::.

In this way, the code of a piece of music developed in this framework could be considered as a sort of technical and abstract score such that any arbitrary and non-error-producing configuration of its modules developed by anyone is, in a musical sense, a valid interpretation, and is, in a software sense, a valid contribution to the project. As such, my hope is to promote a collaborative approach to music making that mirros the ethos of the open source/free software movements in which the SuperCollider project itself is developed.

section::CompositeExample
Developing a class that inherits from CodexComposite is relatively simple. No constructor is needed. The only requirement is that the developer fill out the method link::Classes/CodexComposite#*makeTemplates::, which takes in an instance of link::Classes/CodexTemplater:: as an argument. In fact, it is this method that defines the modules of a class. For instance, if you are making a class requiring a pattern that will be accessed from the modules' event via the key \sequence, then the templater instance must be told to generate a pattern with the name "sequence". note::Templates themselves can be any arbitrary piece of code, and CodexTemplater can be told to reproduce that code so long as it is properly link::Classes/CodexTemplater#ExtendingCodexTemplater#extended::.::

A basic implementation of a class that inherits from CodexComposite is displayed below. In it, a class that defines a single module—a pattern called "sequence"—implements two other methods that play and stop the module.
code::
CompositeExample : CodexComposite {
	var player;
	
	//initComposite is called immediately after modules are loaded into the class. 
	//Initialize instance variables here if you don't want to rewrite the constructor.
	initComposite {}

	*makeTemplates { | templater | 
		templater.pattern( "sequence" );
	}

	play { 
		if(player.isPlaying.not, { 
			player = modules.sequence.play;
		});
	}

	stop { 
		if(player.isPlaying, { 
			player.stop;
		});
	}
}
::

subsection::Usage
Below represents code for interacting with the class whose implementation is displayed immediately above.
code::
x = CompositeExample.new;

//Insepct the modules.
x.modules.postln;

(
//If above was the first time that CompositeExample was instanced, note that a corresponding folder for it now exists in the module directory.
var path = CodexComposite.directory;
PathName(path).folders.do({|item|
	item.folderName.postln;
});
)

(
//Inspecting that folder, see that an entry exists called default by default.
var path = CompositeExample.classFolder;
PathName(path).folders.do({|item|
	item.folderName.postln;
});
)

//Open up the default script files to inspect them or make changes.
x.openModules; 

//If you want to make a new set of modules, that is easy.

//Inspect the modules.
x.modules.postln;

//Open the \experimental set of modules.
//This method is only supported for the editors scide, scvim, and scnvim.
x.openModules; 

//If you edit them, load the changes back into the instance. 
x.reloadScripts; 

//You can switch back and forth between existing modules too.
x.moduleSet = \default;

(
//Note here that no new folder was made.
var path = CodexComposite.directory+/+"CompositeExample";
PathName(path).folders.do({|item|
	item.folderName.postln;
});
)

//If you want to make a new folder cloned from the experimental one...
//edit the file in the \experimental folder, and clone it as follows:
x.moduleSet_(\exp2, \experimental);

//Open the new modules. Unless you edited \experimental, the new modules will look like templates. 
x.openModules;
::

SECTION::CodexHybrid
CodexHybrid extends the procedures of CodexComposite to process SynthDef modules. It does this by reformatting their names to prevent clashes before sending each respective SynthDef to a given server. Moreover, SynthDef modules will only be added to the server when unique collections of modules are added to the cache maintained by CodexComposite.

subsection::SynthDef naming
If a subclass of CodexHybrid defines a SynthDef with the name \helloWorld, then, when the default modules are loaded, that SynthDef's name will be reformatted and added to the server with the symbol \ExampleClass_default_helloWorld. If modules from the set \experimental were cloned from the default set and loaded for the first time, its SynthDef's name would be reformatted and added to the server with the symbol \ExampleClass_experimental_helloWorld. Once these sets of modules are loaded, the class will not re-add the associated SynthDefs for the duration of the server session unless they are removed using link::Classes/CodexHybrid#-removeSynthDefs::. In CodexHybrid, the method teletype::-reloadScripts:: is overwritten to include teletype::-removeSynthDefs:: so that SynthDefs are updated on the server as the modules themselves are updated. 

note:: To ensure that SynthDef names are accessed consistently, it is best not to hardcode the names of SynthDefs either into any modules or class implementations. Rather, calling the method link::Classes/SynthDef#-name#-name:: on the associated SynthDef module will produce more consistent results.
code::
	~someHybrid.modules.synthDef.name;
::
::

section::HybridExample
The below implementation example builds upon the previous one by defining a SynthDef module and replacing the pattern module with a custom template called "patternFunction", which, as its name suggests, returns a function that itself returns a pattern. 

Also, note that that the method teletype::initComposite:: has been replaced with teletype::initHybrid::. The reason for this change is due to the fact that CodexHybrid engages its specialized procedures in the method teletype::initComposite:: making it unavailable. Nevertheless, given the fact that teletype::-initHybrid:: is called upon after the completion of these procedures, it plays an equivalent role for the subclasses of CodexHybrid as teletype::initComposite:: plays for all other subclasses of CodexComposite. 

Finally, HybridExample also makes use of the contribution interface, defining a set of pre-configured modules to be shipped with the class.
code::
HybridExample : CodexHybrid {
	var player;

	*contribute { | versions |
		versions.add(
			[\example, this.filenameString.dirname+/+"Modules"]
		);
	}

	initHybrid {}

	*makeTemplates { | templater |
		templater.patternFunction( "sequence" );
		templater.synthDef( "synthDef" );
	}

	play {
		if(player.isPlaying.not, {
			player = modules.sequence.play;
		});
	}

	stop {
		if(player.isPlaying, {
			player.stop;
		});
	}
}
::
subsection::Usage
Here is an outline of how to interact with the HybridExample class. It should make sounds.

code::
x = HybridExample.new;

//Inspect the modules.
x.modules.postln;

//Inspect the name of the SynthDef.
x.synthDefs[0].name.postln;

//Clone a new moduleSet to observe the new SynthDef name.
x.moduleSet_(\experimental, \default);
x.synthDefs[0].name.postln; 

//Play it to hear sounds.
x.play;
::
