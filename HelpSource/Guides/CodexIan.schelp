TITLE::CodexIan Guide
summary::Guide to working with the library CodexIan
categories::Libraries>CodexIan
related::Overviews/CodexIan, Guides/CodexProxier
keyword::hybrid, composite, composition

section::Description
CodexIan is a collection of classes that establishes a framework for making and developing musical projects in sclang. Objects defined under this framework balance the specificity of a compiled class's interface with the open-ended, experimental potential of scripting. A class written using its features only has to describe high-level interactions between scriptable components whose definitions are largely arbitrary. 

For instance, a class written to sequence patterns in a routine might implement only the routine and then leave the patterns to be loaded from external scripts called modules. As a result, the patterns of this example can be redefined at any point and redeployed without the need for recompiling sclang.  Moreover, the modules themselves can be edited, cloned, and templated at will. In this way, every class developed under this framework can endlessly vary its core functions without additional developmental overhead.

link::Classes/CodexComposite:: coordinates these operations and maintains a directory of sets of modules on behalf of its subclasses. link::Classes/CodexHybrid:: inherits from CodexComposite, handling the process of adding and removing link::Classes/SynthDef:: modules from a given server. 

section::Module directories

Each class that inherits from CodexComposite will have its modules stored in a central directory on the machine. The modules themselves are organized in layers of subfolders that are specified on a per-class-per-collection basis. The path to the directory can be gotten and set through through link::Classes/CodexComposite#*directory::. If the path to the directory of modules is reset, the new configuration will persist across sessions of the link::Classes/Interpreter:: (see link::Classes/CodexStorage::).

note::Be sure to configure the path to the modules directory. By default, the module directory is stored in the folder of this quark.
code::
//Check where the directory is.
CodexComposite.directory.postln;

//Replace this path with something you prefer.
CodexComposite.directory = "~/Documents/scmodules".standardizePath;
::
::
An outline of the directory looks like this:

Module Directory
tree::
	##Class 0
		tree::
			##Module folder
				tree::
					##Module
					##Module
					##Module
				::
			##Module folder
				tree::
					##Module
					##Module
					##Module
				::
		::
	##Class 1
		tree::
			##Module folder
			tree::
				##Module
			::
		::
::

subsection::Class folders
Class folders are generated automatically. However, the circumstances regarding when that happens vary. For instance, a class that contains reference to a preconfigured version of its modules will create both its class folder when sclang is recompiled as well as a subfolder populated with copies of these modules. Moreover, this process will repeat if either of these folders is deleted. If no versions are specified, then once a class is instanced for the first time the framework will generate both the class folder and a folder filled with templates. 

subsection::Module folders
Modules are stored as teletype::.scd:: files within the subfolders of each class folder; each of these subfolders contains variations of the modules templated by the class. As a result, a class expects that modules representing specific sclang objects exist but does not need to now emphasis::how:: they exist. As such, the module loaded from the file teletype::default/sequence.scd:: can be different from the one loaded from the file teletype::experimental/sequence.scd:: so long as both scripts return an object of the same type.

Furthermore, there is no prescribed limit to the number of modular variations that can exist per class. An instance of a subclass of CodexComposite is told to load one of these collections either by supplying a symbol to the teletype::moduleSet:: argument of link::Classes/CodexComposite#*new:: or by setting the value of the field link::Classes/CodexComposite#-moduleSet::. 
note::To see all available module sets, use the method link::Classes/CodexComposite#*moduleSets::::
In both cases, the user has an opportunity to point to a different set of modules by supplying a second argument. When the first set of modules does not already exist and the second set does, the first set will be cloned from the second. If no second set of modules is specified or does not exist, a new corresponding folder of modules will be generated from link::Classes/CodexTemplater##templates::.  

subsection::Modules
As stated above, modules are teletype::.scd:: files containing scripts that return an arbitrary object. When a set of modules is requested for the first time, these scripts are loaded into sclang, collected as an link::Classes/Event::, and stored in an instance of link::Classes/CodexCache::. Copies of the cached modules then can be accessed via link::Classes/CodexComposite#-modules::. The name of each respective module in the event is taken from the name of its source file. For instance, a pattern loaded from teletype::sequence.scd:: is accessible using the key \sequence. Moreover, if the name of the file were teletype::SillySequence.scd::, its associated module would be accessed using the key \sillySequence.

If the source file of a module currently loaded into an instance of a CodexComposite-typed class is edited, simply calling link::Classes/CodexComposite#-reloadScripts:: will reload the objects from the scripts into the cache before copying them into the instance that called the method. Subsequently, all new instances that call for modules from that same collection will reflect these updates. To update currently existing instances, invoking link::Classes/CodexComposite#-reloadModules:: will refresh modules from the now modified cache. This process does not require recompiling sclang.

subsection::Contributing versions 
CodexComposite supports the ability to ship any of its subclasses class with sets of preconfigured modules. This is done by overwriting the method link::Classes/CodexComposite#*contribute#*contribute::, which is passed a link::Classes/List:: that must be supplied with an array of two items: a symbol or string representing the name of the set of modules to be cloned to the directory as well as the path where the modules are currently stored. Ideally, this path should be located within the folder of the project implementing the class. 

There are four short steps required to make a contribution: first, checkout a new branch of your clone of the project; second, add your version of the modules to the project folder; third, point to your projects by adding its name and path (in that order) as an array to the list of versions in the class's implementation; and finally, commit your changes to the branch and submit a pull request for the project. 

By implementing this framework as a platform that publishes diverse approaches to the same projects, my hope is to promote a collaborative music-making process that mirros the ethos of the libre/open-source software movements in which the SuperCollider project itself is developed. As a result, more information about the procedures by which one participates either with CodexIan-based projects or with SuperCollider can be found by visiting the following link: 
link::https://supercollider.github.io/contributing/::.

section::CompositeExample
Developing a class that inherits from CodexComposite is relatively simple. No constructor is needed. The only requirement is that the developer fill out the method link::Classes/CodexComposite#*makeTemplates::, which takes in an instance of link::Classes/CodexTemplater:: as an argument. In fact, it is this method that defines the modules of a class. For instance, if you are making a class that requires a pattern that can be accessed from the modules' event via the key \sequence, then the templater instance must be told to generate a pattern with the name "sequence".

A basic implementation of a class that inherits from CodexComposite is displayed below. There, a single module — a pattern called "sequence" — is defined, and the class implements two other methods that play and stop the module.
code::
CompositeExample : CodexComposite {
	var player;
	
	//initComposite is called immediately after modules are loaded into the class. 
	//Initialize instance variables here if you don't want to rewrite the constructor.
	initComposite {}

	*makeTemplates { | templater | 
		templater.pattern( "sequence" );
	}

	play { 
		if(player.isPlaying.not, { 
			player = modules.sequence.play;
		});
	}

	stop { 
		if(player.isPlaying, { 
			player.stop;
		});
	}
}
::

subsection::Usage
Below represents code for interacting with the class whose implementation is displayed immediately above.
code::
x = CompositeExample.new(\version1);

//Insepct the modules.
x.modules.postln;

(
//A folder now exists in the directory.
var path = CodexComposite.directory;
PathName(path).folders.do({|item|
	item.folderName.postln;
});
)

(
//Inspecting that folder, see that an entry exists for \version1.
var path = CompositeExample.classFolder;
PathName(path).folders.do({|item|
	item.folderName.postln;
});
)

//This is easier done using the .moduleSets class method
CompositeExample.moduleSets;

//Open up the default script files to inspect them or make changes.
x.openModules; 

//If you want to make a new set of modules, that is easy.
x.moduleSet = \version2;

//There are now more moduleSets accessible to the class
CompositeExample.moduleSets.postln;
x.modules.postln;

//Open the \version2 set of modules.
//This method is only supported for the editors scide, scvim, and scnvim.
x.openModules; 

//If you edit them, load the changes back into the instance. 
x.reloadScripts; 

//You can switch back and forth between existing modules too.
x.moduleSet = \version1;

//If you want to make a new folder cloned from the \version2 one...
//edit the file in the \version2 folder, and clone it as follows:
x.moduleSet_(\version3, \version2);

//Open the new modules. Unless you edited \version2, the new modules will look like templates. 
x.openModules;
::

SECTION::CodexHybrid
CodexHybrid extends the procedures of CodexComposite to process SynthDef modules. It does this by reformatting their names to prevent clashes before sending each respective SynthDef to a given server. Moreover, SynthDef modules will only be added to the server when unique collections of modules are added to the cache maintained by CodexComposite.

subsection::SynthDef naming
If a subclass of CodexHybrid defines a SynthDef with the name \helloWorld, then, when the default modules are loaded, that SynthDef's name will be reformatted and added to the server with the symbol \ExampleClass_default_helloWorld. If modules from the set \version2 were cloned from the default set and loaded for the first time, its SynthDef's name would be reformatted and added to the server with the symbol \ExampleClass__helloWorld. Once these sets of modules are loaded, the class will not re-add the associated SynthDefs for the duration of the server session unless they are removed using link::Classes/CodexHybrid#-removeSynthDefs::. In CodexHybrid, the method teletype::-reloadScripts:: is overwritten to include teletype::-removeSynthDefs:: so that SynthDefs are updated on the server as the modules themselves are updated. 

note:: To ensure that SynthDef names are accessed consistently, it is best not to hardcode the names of SynthDefs either into any modules or class implementations. Rather, calling the method link::Classes/SynthDef#-name#-name:: on the associated SynthDef module will produce more consistent results.
code::
	~someHybrid.modules.synthDef.name;
::
::

section::HybridExample
The below implementation example builds upon the previous one by defining a SynthDef module and replacing the pattern module with a custom template called "patternFunction", which, as its name suggests, returns a function that itself returns a pattern. 

Also, note that that the method teletype::initComposite:: has been replaced with teletype::initHybrid::. The reason for this change is due to the fact that CodexHybrid engages its specialized procedures in the method teletype::initComposite:: making it unavailable. Nevertheless, given the fact that teletype::-initHybrid:: is called upon after the completion of these procedures, it plays an equivalent role for the subclasses of CodexHybrid as teletype::initComposite:: plays for all other subclasses of CodexComposite. 

Finally, HybridExample also makes use of the contribution interface, defining a set of preconfigured modules to be shipped with the class.
code::
HybridExample : CodexHybrid {
	var player;

	*contribute { | versions |
		var toQuark = Main.packages.asDict.at(\CodexIan);
		var toExample = toQuark+/+"Classes/Examples/example_modules";

		versions.add(
			[\example, toExample]
		);
	}

	initHybrid {}

	*makeTemplates { | templater |
		templater.hybridExample_function( "sequence" );
		templater.synthDef( "synthDef" );
	}

	play {
		if(player.isPlaying.not, {
			player = modules.sequence.play;
		});
	}

	stop {
		if(player.isPlaying, {
			player.stop;
		});
	}
}
::
subsection::Usage
Here is an outline of how to interact with the HybridExample class. It should make sounds.

code::
//Inspect existing module sets
HybridExample.moduleSets.postln;

//Instance a new HybridExample.
s.waitForBoot({ x = HybridExample.new(\example) });

//Inspect the modules.
x.modules.postln;

//Inspect the name of the SynthDef.
x.modules.synthDef.name.postln;

//Play it to hear sounds. 
x.play;

//Clone a new moduleSet to observe the new SynthDef name.
x.moduleSet_(\example2, \example);
x.modules.synthDef.name.postln;

//Play it to hear sounds.
x.play;
::
